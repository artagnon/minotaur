#!/usr/bin/env perl

# borrowed from souper

# Copyright 2014 The Souper Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use warnings;
use strict;
use Redis;
use Getopt::Long;
use File::Temp;
use Time::HiRes;

my $llvmas  = "@LLVM_BINARY_DIR@/bin/llvm-as";
my $llvmopt = "@LLVM_BINARY_DIR@/bin/opt";
my $llvmdis = "@LLVM_BINARY_DIR@/bin/llvm-dis";

sub runit ($) {
    my $cmd = shift;
    my $res = (system "$cmd");
    return $? >> 8;
}

sub usage() {
    print <<'END';
Options:
  -noopts       Dump not-optimizations instead of optimizations
  -sort=size|sprofile|dprofile|combined
                Sort optimizations by increasing size (default), decreasing
                static profile count, or decreasing dynamic profile count
  -verbose
END
    exit -1;
}

my $REDISPORT = 6379;
my $NOOPTS = 0;
my $SORT = "size";
my $VERBOSE = 0;
my $UNIX = 0;

GetOptions(
    "noopts" => \$NOOPTS,
    "redis-port=i" => \$REDISPORT,
    "sort=s" => \$SORT,
    "verbose" => \$VERBOSE,
    ) or usage();
usage() unless ($SORT eq "size" || $SORT eq "sprofile" || $SORT eq "dprofile" ||
    $SORT eq "combined");

my $noopt_count=0;
my %values;
my %sprofiles;
my %dprofiles;
my %sprofile_locs;
my %dprofile_locs;
my %toprint;

my $r;
if ($UNIX) {
    $r = Redis->new(sock => "@CMAKE_BINARY_DIR@/cache.sock");
} else {
    $r = Redis->new(server => "localhost:" . $REDISPORT);
}
$r->ping || die "no server?";
my @all_keys = $r->keys('*');

print "; Inspecting ".scalar(@all_keys)." Redis values\n";

sub parse ($$) {
    (my $opt, my $RHS) = @_;
    (my $fh, my $tmpfn) = File::Temp::tempfile();
    print $fh $opt;
    $fh->flush();
    open INF, "${llvmdis} < $tmpfn 2>&1 |";
    my $output = "";
    my $success = 0;
    while (my $line = <INF>) {
        $success = 1 if ($line =~ /success/);
        next if ($line =~ /^;/);
        $output .= $line;
    }
    print $output;
    close INF;
    close $fh;
    unlink $tmpfn;
}

sub add_sprofile($$) {
    (my $opt, my $href) = @_;
    my %h = %{$href};
    foreach my $k (keys %h) {
        $sprofile_locs{$opt}{$k} += $h{$k};
    }
    if (!$sprofile_locs{$opt}) {
        $sprofile_locs{$opt} = {};
    }
}

sub add_dprofile($$) {
    (my $opt, my $href) = @_;
    my %h = %{$href};
    foreach my $k (keys %h) {
        $dprofile_locs{$opt}{$k} += $h{$k};
    }
    if (!$dprofile_locs{$opt}) {
        $dprofile_locs{$opt} = {};
    }
}

my $xcnt = 0;
my $tagged = 0;
my $untagged = 0;
# foreach my $opt (@all_keys) {
#     # last if $xcnt++ > 2500;
# #    my %h = $r->hgetall($opt);
# #    my $result = $h{"rewrite"};

#     # if (defined($result)) {
#     #     parse($opt, $result);
#     # } else {
#     #     next;
#     # }

#     my $sprofile = 0;
#     my $dprofile = 0;
#     my %sprofile_loc;
#     my %dprofile_loc;
#     foreach my $kk (keys %h) {
#         if ($kk =~ /^sprofile (.*)$/) {
#             my $count = $h{$kk};
#             $sprofile += $count;
#             $sprofile_loc{$1} += $count;
#         }
#         if ($kk =~ /^dprofile (.*)$/) {
#             my $count = $h{$kk};
#             $dprofile += $count;
#             $dprofile_loc{$1} += $count;
#         }
#     }
#     $opt .= $result;
#     if ($result eq "") {
#         $noopt_count++;
#         $toprint{$opt} = 1 if $NOOPTS;
#     } else {
#         $toprint{$opt} = 1 if !$NOOPTS;
#     }
#     add_sprofile($opt, \%sprofile_loc);
#     add_dprofile($opt, \%dprofile_loc);
#     $sprofiles{$opt} = $sprofile;
#     $dprofiles{$opt} = $dprofile;
# }

print "; Discarding ${noopt_count} not-optimizations leaving ".
    scalar(keys %toprint)." optimizations\n";


print "\n\n";

foreach my $opt (@all_keys) {
    my %h = $r->hgetall($opt);
    my $result = $h{"rewrite"};
    my $oldcost = $h{"oldcost"};
    my $newcost = $h{"newcost"};
    if ($result ne "<no-sol>") {
      parse($opt, $result);
      print $result, "\n";
      print "cost before rewrite: $oldcost\n";
      print "cost after rewrite: $newcost\n";
      print "\n------------------------------------------------------\n";
    }
    # print "\n";
    # print "; total static profile = $sprofiles{$opt}\n";
    # my %h = %{$sprofile_locs{$opt}};
    # foreach my $k (sort { $h{$b} <=> $h{$a} } keys %h) {
    #     next if ($k eq "");
    #     print "; sprofile $h{$k} \"$k\"\n";
    # }
    # print "; total dynamic profile = $dprofiles{$opt}\n";
    # %h = %{$dprofile_locs{$opt}};
    # foreach my $k (sort { $h{$b} <=> $h{$a} } keys %h) {
    #     next if ($k eq "");
    #     print "; dprofile $h{$k} \"$k\"\n";
    # }
}

my $cnt = 0;
foreach my $opt (keys %toprint) {
    $cnt += $sprofiles{$opt};
}
print "; overall total static profile weight = $cnt\n";
print "; $tagged were tagged by cache_infer, $untagged were not\n";
